/** *	                                                             88            *                                                               88            *                                                               88            *     ,adPPYba,    ,adPPYba,   88,dPYba,,adPYba,   8b,dPPYba,   88,dPPYba,    *    a8"     "8a  a8"     "8a  88P'   "88"    "8a  88P'    "8a  88P'    "8a   *    8b       d8  8b       d8  88      88      88  88       d8  88       88   *    "8a,   ,a8"  "8a,   ,a8"  88      88      88  88b,   ,a8"  88       88   *     `"YbbdP"'    `"YbbdP"'   88      88      88  88`YbbdP"'   88       88   *                                                  88                         *                                                  88 *	 *	 * Oomph.as *		-- by default ease type is Quadratic.easeOut, duration is 30, motionBlur is false and motionBlurQuality is medium * * UPDATES * 		-- Delay operates a bit differently now. It wont remove any previous tweens of the same object and props until the delay is reached. *  * TODO * 		-- With new delay functionality, any delayed tweens aren't going to be able to be paused or resume. Fix this! *		-- Allow abilty to add an event listener that returns the object being tweened * 		-- Allow easy tweening of filters ({blurX: 10, blurY: 20, dropBlurX: 10, dropBlurY}) *		-- Add more functionality (Sequencing, get animations by object, etc.); *	 *	 *	BUGS * * @useage * *		import com.oomph.Oomph; * 		Oomph.tweenTo(obj, {x: 10, y: 20}, {ease: Oomph.INOUT, duration: 10, motionBlur: true, blurStrength: .3}); *		 * @author Max Folley 			roar@maxsquatch.com * @version 					2.0.0 * @lasttouchedby 				Max Folley * @lastmodified				February 3, 2010 */package com.oomph{			import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Dictionary;	import flash.utils.Timer;		import ms.utils.ObjectUtil;		public class Oomph	{				private static var _delayedDict:Dictionary = new Dictionary(true);		private static var _tweenInfoDict:Dictionary = new Dictionary(true);		private static var _dispatcher:EventDispatcher = new EventDispatcher();		private static var _oomphUtil:OomphUtil = OomphUtil.getInstance();		private static var _oomphEngine:OomphEngine = OomphEngine.getInstance();		private static var _oomphRegistrar:OomphRegistrar = OomphRegistrar.getInstance();			////////////////////		// Linear easing //		///////////////////		public static const NONE:Function = Easing.none;									// Default ease type				//////////////////////		// Quadratic easing //		//////////////////////		/**		 * Shortcut for Quadratic out ease type.		 */				public static const OUT:Function = Easing.outQuad;		/**		 * Shortcut for Quadratic in ease type.		 */			public static const IN:Function = Easing.inQuad;		/**		 * Shortcut for Quadratic inout ease type.		 */			public static const INOUT:Function = Easing.inOutQuad;		public static const QUADRATIC_OUT:Function = Easing.outQuad;		public static const QUADRATIC_IN:Function = Easing.inQuad;		public static const QUADRATIC_INOUT:Function = Easing.inOutQuad;				////////////////////////		// Exponential easing //		////////////////////////		/**		 * Shortcut for Exponential out ease type. 		 */				public static const STRONG_OUT:Function = Easing.outExpo;		/**		 * Shortcut for Exponential in ease type. 		 */			public static const STRONG_IN:Function = Easing.inExpo;		/**		 * Shortcut for Exponential inout ease type. 		 */			public static const STRONG_INOUT:Function = Easing.inOutExpo;		public static const EXPONENTIAL_OUT:Function = Easing.outExpo;		public static const EXPONENTIAL_IN:Function = Easing.inExpo;		public static const EXPONENTIAL_INOUT:Function = Easing.inOutExpo;				/////////////////////		// Quartic easing //		////////////////////		public static const QUARTIC_OUT:Function = Easing.outQuart;		public static const QUARTIC_IN:Function = Easing.inQuart;		public static const QUARTIC_INOUT:Function = Easing.inOutQuart;				//////////////////		// Sine easing //		/////////////////		public static const SINE_OUT:Function = Easing.outSine;		public static const SINE_IN:Function = Easing.inSine;		public static const SINE_INOUT:Function = Easing.inOutSine;				/////////////////////		// Elastic easing //		////////////////////		public static const ELASTIC_OUT:Function = Easing.outElastic;		public static const ELASTIC_IN:Function = Easing.inElastic;		public static const ELASTIC_INOUT:Function = Easing.inOutElastic;				//////////////////		// Cubic easing //		//////////////////		public static const CUBIC_OUT:Function = Easing.outCubic;		public static const CUBIC_IN:Function = Easing.inCubic;		public static const CUBIC_INOUT:Function = Easing.inOutCubic;				//////////////////		// Back easing //		/////////////////		public static const BACK_OUT:Function = Easing.outBack;		public static const BACK_IN:Function = Easing.inBack;		public static const BACK_INOUT:Function = Easing.inOutBack;				/////////////////////		// Bounce easing //		////////////////////		public static const BOUNCE_OUT:Function = Easing.outBounce;		public static const BOUNCE_IN:Function = Easing.inBounce;		public static const BOUNCE_INOUT:Function = Easing.inOutBounce;				//////////////////////		// Circular easing //		/////////////////////		public static const CIRCULAR_OUT:Function = Easing.outCirc;		public static const CIRCULAR_IN:Function = Easing.inCirc;		public static const CIRCULAR_INOUT:Function = Easing.inOutCirc;				/////////////////////////		// Blur filter quality //		/////////////////////////		/**		 * Low quality for bitmap filter applications. 		 */				public static const LOW:int = 1;		/**		 * Medium quality for bitmap filter applications. 		 */				public static const MEDIUM:int = 2;		/**		 * High quality for bitmap filter applications. 		 */				public static const HIGH:int = 3;				public function Oomph():void		{			trace(Warnings.INIT);		}				/**		 * Creates a timer for a delayed tween and starts its. 		 * @param targetObj:Object		 * @param values:Object		 * @param params:Object		 */				private static function addDelay(targetObj:Object, values:Object, params:Object):void		{			var tmr:Timer = new Timer(params.delay * 1000, 1);			// Save in dict as an object, can reference by the timer			var storedObj:Object = {targetObj: targetObj, values: values, params: params};			// We have two dictionaries to access this object, one where timer is the key and one where the object being tweened is the key			_delayedDict[tmr] = storedObj;						tmr.addEventListener(TimerEvent.TIMER, delayHandler);            tmr.start();		}				public static function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void		{			_dispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);		}				/**		 * Adds the property objects to propInfoDict		 * @param targObj		 * @param propVODict		 * @param param		 * @param prop		 * 		 */				private static function addProperty(targObj:Object, propVODict:Dictionary, param:Object, prop:String):void		{			switch(prop.toLowerCase())			{				case 'color':				var colorObj:Object = _oomphUtil.hexToRGB(param[prop]);				var pObjRed:PropertyVO = new PropertyVO('red', targObj, colorObj.red);				var pObjGreen:PropertyVO = new PropertyVO('green', targObj, colorObj.green);				var pObjBlue:PropertyVO = new PropertyVO('blue', targObj, colorObj.blue);				propVODict['red'] = pObjRed;				propVODict['blue'] = pObjBlue;				propVODict['green'] = pObjGreen;							break;								case 'xy':				var pObjX:PropertyVO = new PropertyVO('x', targObj, param[prop]);				var pObjY:PropertyVO = new PropertyVO('y', targObj, param[prop]);				propVODict['x'] = param[pObjX];				propVODict['y'] = param[pObjY];				break;				case 'scalexy':				var pObjScaleX:PropertyVO = new PropertyVO('scaleX', targObj, param[prop]);				var pObjScaleY:PropertyVO = new PropertyVO('scaleY', targObj, param[prop]);				propVODict['scaleX'] = pObjScaleX;				propVODict['scaleY'] = pObjScaleY;				break;								default:				var pObj:PropertyVO = new PropertyVO(prop, targObj, param[prop]);				// Store the prop name as the key and the propertinfo object as the value				propVODict[prop] = pObj;				break;			}		}				/**		 * If a function is registered to be delayed with delayCall, this will cancel all delays registeres with the function 		 * @param func The function to cancel		 */				public static function cancelCall(func:Function):void		{			_oomphUtil.cancelCall(func);		}								   		/**		 * Some parameters require that a propertyVO instance be available for both x anf y properties of the object 		 * @param params		 * @param propVODict		 */				private static function checkXY(targObj:Object, params:Object, propVODict:Dictionary):void		{			if(params.bezier != null)			{				if(propVODict['x'] == null && propVODict['y'] != null)				{					propVODict['x']  = new PropertyVO('x', targObj, targObj.x);				}				else if(propVODict['y'] == null && propVODict['x'] != null)				{					propVODict['y']  = new PropertyVO('y', targObj, targObj.y);				}			}		}				/**		 * Delays a function call. 		 * @param func:Functon Function to call.		 * @param seconds:Number Number of seconds to delay the function call.		 * @param args Any arguments to pass into the delayed function.		 */				public static function delayCall(func:Function, seconds:Number, ...args):void		{			_oomphUtil.delayCall(func, seconds * 1000, args);		}				/**		 * Pauses any tweens associated with the objects passed as parameters. Can take a number of objects as parameters.		 * @param targetObj		 */				public static function pauseTweens(...args):void		{			var i:int;			var numArgs:int = args.length;			var targetObj:Object;			var infoArr:Array;			while (i < numArgs)			{				targetObj = args[i];				infoArr = _tweenInfoDict[targetObj];				if(infoArr != null)				{					removeEvents(infoArr, true);				}				else				{					trace(Warnings.TWEEN_NOT_FOUND);				}				i++;			}		}				/**		 * Pauses every active tween.		 */				public static function pauseAllTweens():void		{			for(var key:Object in _tweenInfoDict)			{				removeEvents(_tweenInfoDict[key], true);			}		}				/**		 * Loops through timers to check if any are registered for the object, stops and deletes their reference 		 * @param targetObj		 */				private static function removeDelay(targetObj:Object):void		{			var loopObj:Object;			var tmr:Timer;			for(var key:Object in _delayedDict)			{				loopObj = _delayedDict[key];				if(loopObj.targetObj == targetObj)				{					loopObj.params.delay = null;					tmr = key as Timer;					tmr.removeEventListener(TimerEvent.TIMER, delayHandler);            		tmr.stop();            		delete _delayedDict[tmr];				}			}					}				public static function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void		{			_dispatcher.removeEventListener(type, listener, useCapture);		}				private static function removeEvents(tweenInfoArr:Array, isPaused:Boolean = false):void		{			var numTObj:int = tweenInfoArr.length;			var i:int = 0;			var tweenVO:TweenVO;			while(i < numTObj)			{				tweenVO = tweenInfoArr[i];				_oomphEngine.stopTween(tweenVO);				tweenVO.isPaused = isPaused;				i++;			}		}		/**		 * Adds enter frame event back to TweeningObj and resets isPaused 		 * @param tweenInfoArr:Array Info array asociated with tweening object.		 */				private static function resume(tweenInfoArr:Array):void		{			var numTObj:uint = tweenInfoArr.length;			var i:int = 0;			var tweenVO:TweenVO			var tObj:TweeningObject;			while(i < numTObj)			{				tweenVO = tweenInfoArr[i];				tObj = tweenVO.tweeningObj;				if(tweenVO.isPaused)				{					_oomphEngine.runTween(tweenVO);					tweenVO.isPaused = false;				}				i++;			}		}				/**		 * Resumes any paused tweens for the passed objects. 		 * @param targetObj		 */				public static function resumeTweens(...args):void		{			var i:int;			var numArgs:int = args.length;			var targetObj:Object;			var infoArr:Array;			while (i < numArgs)			{				targetObj = args[i];				infoArr = _tweenInfoDict[targetObj];				if(infoArr != null)				{					resume(infoArr);				}				else				{					trace(Warnings.TWEEN_NOT_FOUND);				}				i++;			}		}				/**		 * Resumes any paused tweens. 		 * @param targetObj		 */				public static function resumeAllTweens():void		{			for(var key:Object in _tweenInfoDict)			{				resume(_tweenInfoDict[key]);			}		}				/**		 * Searches the tweens, and if one is found with the same property specified for a different tween, it stops it.		 * @param targCont		 * @param propDict		 * @param modifiers		 * @return 		 */				private static function searchAndEnumerate(targObj:Object, propDict:Dictionary, modifiers:Object):TweenVO		{			// If removeOldDelays, search for delays previously registered and remove them			if(modifiers.removeOldDelays == true)			{				// Check if it has properties already registered to tween but the has a delay				var delayObj:Object;				for(var tmr:Object in _delayedDict) {					delayObj = _delayedDict[tmr];					if(delayObj.targetObj == targObj) {						var matchFound:Boolean;						// Loop through values to check for property name match						var numDeleted:int;						var numProps:int;						for(var prop:String in delayObj.values) {							if(propDict[prop] != null) {								matchFound = true;								delete delayObj.values[prop];								numDeleted++							}							numProps++;						}						// If all propertes for the value object have been deleted, remove its delay completely						if(numDeleted == numProps) {							tmr.stop();							delete _delayedDict[tmr];							tmr = null;						}					}				}				}						var tweenVO:TweenVO;			// Check if the targObj is already tweening			var tweenVOArr:Array = _tweenInfoDict[targObj];			if(tweenVOArr != null) {								// Loop through all the TweenInfoObjects associated with the object and search for similar properties				var numTweenObjects:uint = tweenVOArr.length;				var i:uint = 0;				var numTweens:int = tweenVOArr.length;				var propName:String;				var registeredTween:TweenVO;				while(i < numTweens)				{					registeredTween = tweenVOArr[i];					// Loop through each property that is trying to be tweened and search for it in each registered tween info object					for(var key:String in propDict)					{						propName = key.toString();						// Check if the property is already being tweened						if(registeredTween.tweenables[propName])						{							// Remove the property object from the tween and create a new tween for the property							delete registeredTween.tweenables[propName];						}					}					// Check if any properties remain to be tweened in the TweenInfoObject, if not, delete the object					var stillTween:Boolean = registeredTween.checkTweenables();										if(!stillTween)					{						// Remove the enter frame event and timer event to stop the tween, and remove it from the listener						registeredTween.tweeningObj.destroy();												// Remove it from the array that contains all the tween info objects						tweenVOArr.splice(i, 1);						// Adjust num tweens for the loop						numTweens = tweenVOArr.length;						registeredTween = null;					// Only increment i if the item isnt found for removal, since the array has been adjusted					}					else					{						i++;					}									} 				// Create the new TweenInfoObject for the new property values				tweenVO = new TweenVO(targObj, propDict, modifiers);				tweenVOArr.push(tweenVO);			}			else			{								// Create the first tween info object for the specified target				tweenVO = new TweenVO(targObj, propDict, modifiers);				// Create new array with new tweenVO in it				_tweenInfoDict[targObj] = [tweenVO];			}			return tweenVO;		}				/**		 * Rather than tweening objects, you can use this to strictly set any property available for a tween in Oomph.		 * @param targObj		 * @param paramObj		 */				public static function setProperties(targObj:Object, paramObj:Object):void		{				var tObj:TweeningObject = new TweeningObject(targObj);			for(var key:Object in paramObj)			{				tObj[key] = paramObj[key];			}			_oomphUtil.call();		}				/**		 * Called from tweenTo and after a delay from tweenTo has finished 		 * @param targetObj		 * @param values		 * @param params		 * @param ignoreDelay		 */				private static function startTween(targetObj:Object, values:Object, params:Object = null, ignoreDelay:Boolean = false):void		{						// Creates the property information objects			var propInfoDict:Dictionary = new Dictionary(true);						// Loop through values and create and register proper4ty vo's			for(var prop:String in values)			{				var propVO:PropertyVO;				/* 					If it matches one of the available properties that can be tweened or it's					a property of the object to be tweened, create its PropertyInfoObj.				*/				if(_oomphRegistrar.checkProp(prop) || targetObj[prop] != undefined)				{					addProperty(targetObj, propInfoDict, values, prop);				}				else				{					trace(Warnings.WRONG_PROP + ": " + prop);				}			}								/*				Apply the one set of params for every object set to tween,				most the time will end up being one tweenVO per tweening object, 				but the target object can be an array of objects to tween for 				one value object and one paramater object			*/			checkXY(targetObj, params, propInfoDict);			var tweenVO:TweenVO = searchAndEnumerate(targetObj, propInfoDict, params);						if(!_oomphEngine.hasEventListener(OomphEvent.TWEEN_COMPELTE)) _oomphEngine.addEventListener(OomphEvent.TWEEN_COMPELTE, completeHandler);						if(tweenVO.startHandler != null) tweenVO.startHandler.apply(targetObj, tweenVO.startParams);			// Run the tween by passing the modified _tweenInfoDict into the engine			_oomphEngine.runTween(tweenVO);		}				/**		 * Stops every tween that is currently registered with Oomph.		 */				public static function stopAllTweens():void		{			// Loop through all info object arrays in the dictionary			for(var key:Object in _tweenInfoDict)			{				removeDelay(key);				removeEvents(_tweenInfoDict[key]);				delete _tweenInfoDict[key];			}		}		/**		 * Stops any tweens associated with the objects passed as parameters. Can take a number of objects as parameters.		 * Tweens will no longer be available after this function is called, to stop and resume a tween you must use pauseTweens().		 * @param rest - any number of tweens that you wont to stop		 */				public static function stopTweens(...args):void		{			var i:int;			var numArgs:int = args.length;			var targetObj:Object;			var infoArr:Array;			while (i < numArgs)			{				targetObj = Object(args[i]);				if(targetObj != null)				{					// Make sure to remove delay here, because if it has a delay and it hasnt run yet, it probably wont be in the _tweenInfoDict yet since no tween has been registered 					removeDelay(targetObj);					infoArr = _tweenInfoDict[targetObj];					if(infoArr != null)					{						removeEvents(infoArr);						delete _tweenInfoDict[targetObj];					}					else					{						trace(Warnings.TWEEN_NOT_FOUND);					}				}				i++;			}		}				/**		 * Main function used to tween an object.		 * @param targetObj:Object Object to tween, can be anything with public properties.		 * @param values:Object targetObj Properties to tween and their ending values. Any publicly accessible property of the targetObj can be tweened (i.e. alpha, x, y, volume). There are some special properties that arent properties of the targetObj that can be tweened:		 * <p>		 * <ul>		 * <li>blue:<code>Number</code> - 0 - 255, use in combination with the tint property. Amount of blue to apply to the tint value.</li>		 * <li>color:<code>uint</code> - Color hex value to tween color of targetObj to.</li>		 * <li>frame:<code>Number</code> - If the targetObj is a MovieClip, Oomph will tween its frame from the current frame to the passed value.</li>		 * <li>green:<code>Number</code> - 0 - 255, use in combination with the tint property. Amount of green to apply to the tint value.</li>		 * <li>red:<code>Number</code> - 0 - 255, use in combination with the tint property. Amount of red to apply to the tint value.</li>		 * <li>scaleXY:<code>Number</code> - shortcut for tweening scaleX and scaleY at the same time.</li>		 * <li>tint:<code>Number</code> - 0 - 1, tints the targetObj using the blue, green and red property values.</li>		 * <li>xy:<code>Number</code> - Shortcut for tweening x and y at the same time.</li>		 * </ul>		 * </p>		 * 		 * @param params:Object Parameters for the tween		 * <p>		 * <ul>		 * <li>amplitude:<code>Number</code> (default = <code>0</code>) – Amplitude for Elastic ease type.</li>		 * <li>beginColor:<code>uint</code> (default = <code>0x000000</code>) – Beginnig color for color tweens.</li>		 * <li>bezier:<code>Object</code> – Can be an object containing x and y values or an array of objects containing x and y values.</li>		 * <li>blurQuality:<code>int</code> (default = <code>Oomph.MEDIUM</code>) – Quality of blur filter used for the motionBlur parameter, use Oomph constants.</li>		 * <li>blurStrength:<code>Number</code> (default = <code>.3</code>) – Strength of the motionBlur, range is 0 - 1.</li>		 * <li>completeHandler:<code>Function</code> – Function to call when tween has completed.</li>		 * <li>completeParams:<code>Array</code> – Array of parameters to pass into the completeHandler.</li>		 * <li>delay:<code>Number</code> – Seconds before the tween starts.</li>		 * <li>duration:<code>Number</code> (default = <code>30</code>) – Number of frames to run the animation. Recommended over seconds.</li>		 * <li>ease:<code>Function</code> (default = <code>Oomph.NONE</code>) – Equaton to apply to , use Oomph constants.</li>		 * <li>loops:<code>Number</code> – Number of times to run the tween.</li>		 * <li>motionBlur:<code>Boolean</code> (default = <code>fatweenlse</code>) – If true, a blur filter is applied to the object based on its x and y displacement.</li>		 * <li>overshoot:<code>Number</code> (default = <code>1.70158</code>) – Amount to overshoot when using Back ease type.</li>		 * <li>period:<code>Number</code> (default = <code>0</code>) – Period for Eastic ease type.</li>		 * <li>progressHandler:<code>Number</code> – Function that gets called on every frame of the animation.</li>		 * <li>progressParams:<code>Array</code> – Array of parameters that get passed into the progressHandler.</li>		 * <li>rate:<code>Number</code> (default = <code>33</code>) – Rate, in milliseconds, at which tween gets updated when tween is using seconds instead of duration.</li>		 * <li>reverseYoYo:<code>Boolean</code> (default = <code>false</code>) – Same as yoyo but Oomph will use the opposing ease type in the reverse animation.</li>		 * <li>removeOldDelays:<code>Boolean</code> (default = <code>false</code>) – If true, Oomph will remove any delays for matching tweens previously registered with the tweenTo function.</li>		 * <li>removeOnFinish:<code>Boolean</code> (default = <code>false</code>) – If true, Oomph will remove the object from its parent's display list when the animation is complete.</li>		 * <li>seconds:<code>Number</code> (default = <code>0</code>) – Number of seconds to run the tween, if seconds are used, duration is ignored. It is recommended that frame based animations are used for optimization purposes. With frame based animations, one enter frame event handler is required to handle all tween updates in Oomph, where using seconds based animations requires a seperate timer for every tween since different rates of the tween can be requested.</li>		 * <li>showBezier:<code>Boolean</code> (default = <code>false</code>) – If true, Oomph will draw out the bezier curve using the bezier parameter.</li>		 * <li>startHandler:<code>Function</code> – Function to call when tween starts.</li>		 * <li>startParams:<code>Array</code> – Array of parameters to pass into startHandler.</li>		 * <li>yoyo:<code>Boolean</code> (default = <code>false</code>) – If true, the tween runs then reverses and continues to loop like this.</li>		 * </ul>		 * </p>		 * 		 * @example The following code tweens an object x and y properties:		 * <listing version="3.0">		 * import com.oomph.Oomph;		 * Oomph.tweenTo(myObj, {x: 200, y: 400}, {ease: Oomph.INOUT, duration: 10});		 * </listing> 		 * 		 * @example The following code tweens an object x and y properties along a bezier curve after delaying it for a second:		 * <listing version="3.0">		 * import com.oomph.Oomph;		 * 		 * var bezier:Array = [{x: 100, y: 200}, {x: 150, y: 600}];		 * Oomph.tweenTo(myObj,		 *				 {x: 200, y: 400},		 *				 {bezier: bezier, ease: Oomph.EXPONENTIAL_OUT, duration: 10, delay: 1});		 * </listing>		 * 		 * @example The following code tweens an object x and y properties and calls a function with paramaters whe it is complete:		 * <listing version="3.0">		 * import com.oomph.Oomph;		 * Oomph.tweenTo(myObj, {x: 200, y: 400}, {ease: Oomph.BOUNCE_OUT, duration: 10, completeHandler: complete, completeParams: ["hello world"]});		 * 		 * private function complete(str:String):void		 * {		 *		trace(str);		 * }		 * </listing> 		 */				public static function tweenTo(targetObj:Object, values:Object, params:Object = null):void		{			if(params == null) params = {};			// If there is a delay, set it and call tweenTo after timer is fired			if(params.delay)			{				addDelay(targetObj, values, params);				return;			}						startTween(targetObj, values, params);		}				//---------------------------------------		// EVENT HANDLERS		//---------------------------------------		/**		 * Call tween completeHandler and remove tween from memory		 * @param event:OomphEvent		 */				private static function completeHandler(event:OomphEvent):void		{			var tweenVO:TweenVO = event.tweenVO;			var tObj:TweeningObject = tweenVO.tweeningObj;			var targObj:Object = tObj.targObj;			var tweenInfoArr:Array = _tweenInfoDict[targObj];			var numTObj:uint = tweenInfoArr.length;			var i:int = 0;			while(i < numTObj)			{				if(tweenInfoArr[i] == tweenVO)				{					tweenInfoArr.splice(i, 1);					numTObj = tweenInfoArr.length;					// Set back one to make up for lost item					i--;				}				i++;			}								// Call the motion finished			if(tweenVO.completeHandler != null)			{				try				{					tweenVO.completeHandler.apply(targObj, tweenVO.completeParams);				}				catch (error:ReferenceError)				{					trace(Warnings.FUNCTION_FAILURE);				}			}						// Remove from the display list			if(tweenVO.removeOnFinish == true)			{				if(targObj.parent != null)				{					if(targObj.parent.contains(targObj))					{						targObj.parent.removeChild(targObj);					}				}			}						/* 				Remove object from dictionary when no tweens are left,				also make sure it gets removed from memory.			*/			if(numTObj == 0)			{				tweenVO.tweeningObj.destroy();				delete _tweenInfoDict[tweenVO];				tweenVO = null;			}						event.tweenVO = null;			event = null;						_dispatcher.dispatchEvent(new OomphEvent(OomphEvent.TWEEN_COMPELTE));		}				private static function delayHandler(event:TimerEvent):void		{			var tmr:Timer = event.target as Timer;			tmr.removeEventListener(TimerEvent.TIMER, delayHandler);						var storedObj:Object = _delayedDict[tmr];			delete _delayedDict[tmr];						tmr = null;						Oomph.startTween(storedObj.targetObj, storedObj.values, storedObj.params, true);			// Ensures storedObj is removed from memory			storedObj = null;		}			}}